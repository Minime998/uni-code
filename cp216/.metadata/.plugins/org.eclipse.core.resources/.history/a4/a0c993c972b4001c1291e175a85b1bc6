/*
 -------------------------
 File: File Name
 Project: Project name
 -------------------------
 Author: Matthew Borkowski
 ID: 201588010
 Email: bork8010@mylaurier.ca
 Version YYYY-MM-DD
 -------------------------
 */

#include <stdio.h>
#include <stdlib.h>
#include "heap.h"
#include "algorithm.h"

EDGELIST *mst_prim(GRAPH *g, int start) {
	//if no graph return null
	if (g == NULL)
		return NULL;

	int i, heapindex, n = g->order;
	int T[n], parent[n];
	HNODE hn;
	//label all nodes inside the T array
	for (i = 0; i < n; i++) {
		T[i] = 0;
		parent[i] = -1;
	}

	HEAP *h = new_heap(4);
	//get neighbors of root
	ADJNODE *temp = g->nodes[start]->neighbor;
	T[start] = 1;
	//add all neighbors of root node to heap
	while (temp) {
		hn.key = temp->weight;
		hn.data = temp->nid;
		insert(h, hn);
		parent[temp->nid] = start;
		temp = temp->next;
	}
	//initialize an edgelist to hold the mst
	EDGELIST *mst = new_edgelist();
	//add all edges to the mst
	//heap will store at most 4 values (in this example) since there will never be duplicate nodes added
	//any time a duplicate node is added instead of actually inserting it you just decrease_key
	while (h->size > 0) {
		//take the minimum edge from G connected to nodes already in mst
		hn = extract_min(h);
		i = hn.data;
		T[i] = 1;
		//add this edge to the mst
		add_edge_end(mst, parent[i], i, hn.key);
		//add all neighbors of this new node to the heap
		temp = g->nodes[i]->neighbor;
		while (temp) {
			//find the node in the heap
			heapindex = find_data_index(h, temp->nid);
			//if the node is in the heap then relax it
			if (heapindex >= 0) {
				if (T[temp->nid] == 0
						&& temp->weight < h->hna[heapindex].key) {
					decrease_key(h, heapindex, temp->weight);
					parent[temp->nid] = i;
				}
			} else {
				if (T[temp->nid] == 0) {
					hn.key = temp->weight;
					hn.data = temp->nid;
					insert(h, hn);
					parent[temp->nid] = i;
				}
			}
			temp = temp->next;
		}
	}
	return mst;
}

EDGELIST *spt_dijkstra(GRAPH *g, int start) {
// your implementation
}

EDGELIST *sp_dijkstra(GRAPH *g, int start, int end) {
// your implementation
}
